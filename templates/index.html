<!doctype html>
<html>
<head>
<meta charset="utf-8">
<title>Twitch News Ticker</title>
<style>
body { 
    background: #1a1a1a;
    color: white; 
    font-family: 'Segoe UI', Arial, sans-serif;
    overflow: hidden; 
    margin: 0;
    padding: 0;
    display: flex;
    align-items: center;
    justify-content: center;
    min-height: 100vh;
}

.ticker-container {
    position: relative;
    width: 100%;
    height: 80px;
    background: linear-gradient(90deg, #9146ff 0%, #9146ff 120px, #ffffff 120px, #ffffff 100%);
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    border-radius: 8px;
    overflow: hidden;
}

.ticker-label {
    position: absolute;
    left: 0;
    top: 0;
    width: 120px;
    height: 100%;
    background: #9146ff;
    display: flex;
    align-items: center;
    justify-content: center;
    color: white;
    font-weight: bold;
    font-size: 2.2em;
    text-transform: uppercase;
    letter-spacing: 1px;
    z-index: 10;
    box-shadow: 2px 0 10px rgba(0,0,0,0.2);
}

.ticker-label::after {
    content: '';
    position: absolute;
    right: -10px;
    top: 50%;
    transform: translateY(-50%);
    width: 0;
    height: 0;
    border-left: 10px solid #9146ff;
    border-top: 15px solid transparent;
    border-bottom: 15px solid transparent;
}

.marquee { 
    position: absolute;
    left: 120px;
    right: 0;
    top: 0;
    height: 100%;
    white-space: nowrap; 
    overflow: hidden; 
    display: flex;
    align-items: center;
    background: white;
}

.track { 
    display: flex;
    align-items: center;
    height: 100%;
    white-space: nowrap;
    will-change: transform;
    transform: translateX(0);
}

.item { 
    margin-right: 100px; 
    color: #333333;
    font-weight: 600;
    font-size: 2.6em;
    text-shadow: none;
    display: inline-block;
    flex-shrink: 0;
}

.item::before {
    content: "•";
    color: #9146ff;
    margin-right: 15px;
    font-size: 1em;
}

.item.new {
    opacity: 0;
    transform: scale(0.8);
    animation: slideIn 0.8s ease-out forwards;
}

.item.old {
    opacity: 0.7;
    filter: brightness(0.8);
}

@keyframes slideIn {
    0% {
        opacity: 0;
        transform: scale(0.8) translateY(-10px);
    }
    50% {
        opacity: 0.8;
        transform: scale(1.05) translateY(0px);
    }
    100% {
        opacity: 1;
        transform: scale(1) translateY(0px);
    }
}

/* Status indicator */
.status {
    position: fixed;
    top: 20px;
    right: 20px;
    background: rgba(0, 0, 0, 0.8);
    padding: 8px 12px;
    border-radius: 20px;
    font-size: 0.8em;
    z-index: 100;
    transition: all 0.3s ease;
}

.status.connected { 
    border-left: 3px solid #00ff00; 
    background: rgba(0, 100, 0, 0.2);
}
.status.error { 
    border-left: 3px solid #ff0000;
    background: rgba(100, 0, 0, 0.2);
}

/* Debug info */
.debug {
    position: fixed;
    top: 60px;
    right: 20px;
    background: rgba(0, 0, 0, 0.9);
    padding: 10px;
    border-radius: 8px;
    font-size: 0.7em;
    font-family: monospace;
    z-index: 99;
    display: none;
    min-width: 200px;
}

.debug.show { display: block; }

/* Gradient fade edges */
.marquee::before {
    content: '';
    position: absolute;
    left: 0;
    top: 0;
    width: 30px;
    height: 100%;
    background: linear-gradient(90deg, rgba(255,255,255,1) 0%, rgba(255,255,255,0) 100%);
    z-index: 5;
    pointer-events: none;
}

.marquee::after {
    content: '';
    position: absolute;
    right: 0;
    top: 0;
    width: 30px;
    height: 100%;
    background: linear-gradient(90deg, rgba(255,255,255,0) 0%, rgba(255,255,255,1) 100%);
    z-index: 5;
    pointer-events: none;
}

/* Responsive scaling */
@media (max-width: 1200px) {
    .item { font-size: 2em; }
    .ticker-container { height: 90px; }
    .ticker-label { font-size: 1.8em; }
}

@media (max-width: 800px) {
    .item { font-size: 1.3em; }
    .ticker-container { height: 70px; }
    .ticker-label { width: 100px; font-size: 1.4em; }
    .marquee { left: 100px; }
}
</style>
</head>
<body>
<div class="status" id="status">Connecting...</div>

<div class="debug" id="debug">
    <div>Headlines: <span id="headline-count">0</span></div>
    <div>Visible Items: <span id="visible-count">0</span></div>
    <div>Scroll Speed: <span id="current-speed">0</span>px/s</div>
    <div>Last Update: <span id="last-update">Never</span></div>
    <div>Version: <span id="version">0</span></div>
</div>

<div class="ticker-container">
    <div class="ticker-label">Live</div>
    <div class="marquee">
        <div id="track" class="track"></div>
    </div>
</div>

<script>
const track = document.getElementById('track');
const container = document.querySelector('.marquee');
const statusEl = document.getElementById('status');
const debugEl = document.getElementById('debug');
const CONFIG = {{ config|safe }};

const SPEED = CONFIG.TICKER_SPEED || 50; // pixels/sec
const POLL_INTERVAL = CONFIG.API_POLL_INTERVAL || 3000;
const MAX_FAILURES = CONFIG.API_MAX_FAILURES || 5;
const MAX_HEADLINES = 25;
const OLD_HEADLINE_THRESHOLD = 15;

let lastVersion = -1;
let failureCount = 0;
let isPolling = false;
let knownHeadlines = new Set();
let headlineHistory = [];
let debugVisible = false;

// Scroll state
let offset = container.offsetWidth; // start from right edge
let lastTimestamp = null;

function setStatus(message, className) {
    statusEl.textContent = message;
    statusEl.className = `status ${className}`;
}

function updateDebugInfo() {
    if (!debugVisible) return;
    document.getElementById('headline-count').textContent = headlineHistory.length;
    document.getElementById('visible-count').textContent = track.children.length;
    document.getElementById('current-speed').textContent = SPEED;
    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
    document.getElementById('version').textContent = lastVersion;
}

function createItem(text, isNew = false) {
    const span = document.createElement('span');
    span.className = `item ${isNew ? 'new' : ''}`;
    span.textContent = text;
    span.dataset.headline = text;
    return span;
}

function addNewHeadlines(newItems) {
    if (!Array.isArray(newItems) || newItems.length === 0) return;
    newItems.forEach(headline => {
        if (knownHeadlines.has(headline)) return;
        knownHeadlines.add(headline);
        headlineHistory.push({ text: headline, timestamp: Date.now() });
        const element = createItem(headline, true);
        track.appendChild(element);
        setTimeout(() => element.classList.remove('new'), 800);
    });
    ageHeadlines();
    cleanupOldHeadlines();
    updateDebugInfo();
}

function ageHeadlines() {
    const items = track.children;
    const total = items.length;
    Array.from(items).forEach((item, i) => {
        if (i < total - OLD_HEADLINE_THRESHOLD) {
            item.classList.add('old');
        } else {
            item.classList.remove('old');
        }
    });
}

function cleanupOldHeadlines() {
    while (track.children.length > MAX_HEADLINES) {
        const oldest = track.children[0];
        knownHeadlines.delete(oldest.dataset.headline);
        headlineHistory = headlineHistory.filter(h => h.text !== oldest.dataset.headline);
        track.removeChild(oldest);
    }
}

function initializeEmptyState() {
    if (track.children.length === 0) {
        const placeholder = createItem('Breaking news! The stream is live!');
        placeholder.classList.add('placeholder');
        track.appendChild(placeholder);
    }
}

function removeEmptyState() {
    const placeholder = track.querySelector('.placeholder');
    if (placeholder) placeholder.remove();
}

async function fetchHeadlines() {
    if (isPolling) return;
    isPolling = true;
    try {
        const res = await fetch('/api/headlines?ts=' + Date.now(), { cache: "no-store", signal: AbortSignal.timeout(10000) });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        failureCount = 0;
        setStatus(`Connected • ${headlineHistory.length} headlines`, 'connected');
        if (data.version !== lastVersion) {
            lastVersion = data.version;
            const newItems = data.items || [];
            if (newItems.length > 0) {
                removeEmptyState();
                addNewHeadlines(newItems);
            }
            updateDebugInfo();
        }
    } catch (e) {
        console.error("fetchHeadlines failed:", e);
        failureCount++;
        setStatus(`Error (${failureCount}/${MAX_FAILURES})`, 'error');
        if (failureCount >= MAX_FAILURES) {
            window.location.reload();
            return;
        }
    } finally {
        isPolling = false;
    }
}

// Smooth scrolling loop
function tickScroll(timestamp) {
    if (!lastTimestamp) lastTimestamp = timestamp;
    const delta = (timestamp - lastTimestamp) / 1000;
    lastTimestamp = timestamp;

    offset -= SPEED * delta;
    const trackWidth = track.scrollWidth;

    if (offset + trackWidth < 0) {
        offset = container.offsetWidth; // reset to right
    }

    track.style.transform = `translateX(${offset}px)`;
    requestAnimationFrame(tickScroll);
}

// Keyboard controls
document.addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'd') {
        debugVisible = !debugVisible;
        debugEl.classList.toggle('show', debugVisible);
        if (debugVisible) updateDebugInfo();
    }
    if (e.key.toLowerCase() === 'r') {
        lastVersion = -1;
        fetchHeadlines();
    }
    if (e.key.toLowerCase() === 'c') {
        track.innerHTML = '';
        knownHeadlines.clear();
        headlineHistory = [];
        initializeEmptyState();
    }
});

async function startPolling() {
    while (true) {
        await fetchHeadlines();
        await new Promise(resolve => setTimeout(resolve, POLL_INTERVAL));
    }
}

// Init
document.addEventListener('DOMContentLoaded', () => {
    initializeEmptyState();
    startPolling();
    requestAnimationFrame(tickScroll);
});
</script>
</body>
</html>
